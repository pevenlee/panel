# 对话框后端运行逻辑说明

## 1. 完整运行逻辑（一次用户提问的端到端流程）

```
用户在前端输入文本并发送
    ↓
前端 POST /api/query  { text, history? }
    ↓
main.py: query_data(request)
    ↓
判断：gemini_engine._get_client() 是否为 None？
    ├─ 不为 None（已配置 GENAI_API_KEY）
    │       ↓
    │   使用 Gemini 引擎：gemini_engine.process_query_with_gemini(text, history_context)
    │       ↓
    │   [见下方「Gemini 引擎分支」]
    │
    └─ 为 None（未配置或加载失败）
            ↓
        使用规则引擎：data_engine.process_query(request.text)
            ↓
        [见下方「规则引擎分支」]
    ↓
若 result 中有 "error"，则 HTTP 400，detail=result["error"]
否则 return result（前端收到 data / title / logicDescription / config 等）
```

### 规则引擎分支（无 API，纯本地）

- **入口**：`backend/app/engine.py` 的 `DataEngine.process_query(query_text)`
- **步骤**：
  1. 从 `data/hcmdata.xlsx` 读入的 `self.df` 做 copy。
  2. 根据用户文本关键词推断「逻辑维度」和「逻辑指标」（如 省→Province，额→SalesAmount）。
  3. 用 `_find_column(df, candidates)` 在真实表头中匹配实际列名（支持中英文，如 药品名称、销售额）。
  4. 若匹配不到，用兜底：第一个非数值列作维度、第一个数值列作指标。
  5. 可选简单过滤（如 2024、江苏）。
  6. 按维度列 groupby，对指标列 sum，排序后转成 `[{ name, value }, ...]`。
  7. 返回 `{ data, title, logicDescription, config }`。
- **不调用任何外部 API**。

### Gemini 引擎分支（调用 Google Gemini API）

- **入口**：`backend/app/gemini_engine.py` 的 `process_query_with_gemini(query_text, ..., history_context)`
- **前置**：若未传入 df/time_context/meta_data，则 `get_cached_data()`：`load_data()` 读 `data/hcmdata.xlsx`（可选关联 `structure.xlsx`），再 `analyze_time_structure(df)`、`build_metadata(df, time_context)`，并缓存。
- **步骤概览**：
  1. **意图路由**：调用 Gemini 一次，得到 `simple` / `analysis` / `irrelevant`。
  2. 若 `irrelevant`：直接返回固定文案，不再调 API。
  3. 若 `simple`：再调 Gemini 一次得到「summary + code」→ 本地 `exec(code)` → 用第一个结果表转图表数据，返回。
  4. 若 `analysis`：再调 Gemini 一次得到「intent_analysis + angles」→ 对每个 angle 本地 `exec(angle["code"])`，再对每个角度调 Gemini 做「深度解读」→ 最后再调 Gemini 一次做「综合洞察」→ 用第一个角度的数据作主图表，返回。

---

## 2. 哪些地方调用了 API（仅 Gemini 分支）

**所有 API 均为 Google Gemini API**，通过 `google.genai` 的 `client.models.generate_content(...)` 调用。

| 序号 | 所在文件与位置 | 作用 |
|-----|----------------|------|
| ① | `gemini_engine.process_query_with_gemini`：意图路由 | 判断 simple / analysis / irrelevant |
| ② | `gemini_engine.process_query_with_gemini`：Simple 模式 | 生成「summary + code」JSON |
| ③ | `gemini_engine.process_query_with_gemini`：Analysis 模式 - 拆解角度 | 生成「intent_analysis + angles」JSON |
| ④ | `gemini_engine.process_query_with_gemini`：Analysis 模式 - 每个角度 | 对每个 angle 的结果表做「深度解读」（循环内，每角度 1 次） |
| ⑤ | `gemini_engine.process_query_with_gemini`：Analysis 模式 - 综合洞察 | 根据各角度发现生成最终洞察（1 次） |

- **规则引擎**（未配置 `GENAI_API_KEY` 或 client 为 None）：**不调用任何 API**。

---

## 3. 每次调用的模型是什么

当前代码里**全部使用同一模型**：`gemini-2.0-flash`。

| 调用点 | 模型名 |
|--------|--------|
| 意图路由 | `gemini-2.0-flash` |
| Simple：取数代码生成 | `gemini-2.0-flash` |
| Analysis：分析计划（角度拆解） | `gemini-2.0-flash` |
| Analysis：每个角度的深度解读 | `gemini-2.0-flash` |
| Analysis：综合洞察 | `gemini-2.0-flash` |

- 意图路由、Simple 的代码生成两处使用了 `response_mime_type="application/json"`，其余为默认文本输出。

---

## 4. 输入了什么提示词（Prompt）

以下为各次 API 调用时传入的 **contents**（即发给模型的提示词）。

### ① 意图路由

- **模型**：`gemini-2.0-flash`，JSON 输出。
- **提示词**（`router_prompt`，约 320–330 行）：

```text
基于用户当前问题："{query_text}" 以及历史上下文判断用户意图。
【历史上下文】: {history_context}
请将其分类为以下三类之一：
1. "simple": 简单取数、排序、排名、计算基础指标。
2. "analysis": 开放式问题，寻求洞察、原因分析、市场格局。
3. "irrelevant": 与数据完全无关的闲聊。
仅输出 JSON: {"type": "simple" 或 "analysis" 或 "irrelevant"}
```

- `history_context` 由 `get_history_context(request.history, turn_limit=3)` 生成，为最近几轮对话的摘要文本。

---

### ② Simple 模式（取数代码生成）

- **模型**：`gemini-2.0-flash`，JSON 输出。
- **提示词**（`simple_prompt`，约 350–367 行）：

```text
你是一位医药行业的 Pandas 数据处理专家。用户需求："{query_text}"
【元数据】{meta_data}
【历史记录】{history_context}
【时间上下文】MAT: {mat_list}, YTD: {ytd_list}

【关键指令 - 必须遵守】
1. 唯一数据源：环境中只有 `df`。不要假设存在 df_sales, df_hainan 等变量。
2. 必须自行筛选：如需特定维度（如海南、2023年），必须在代码中显式筛选。
3. 禁止臆造 Key：不要假设数据中存在不存在的具体值。请先检查 unique 或使用模糊匹配。
4. 结果赋值：将最终结果字典赋值给 `results`，例如 results = {'查询结果': df_sub}。
5. 严禁绘图。
6. 提到市场表现时，尽可能给份额、同比、份额变化、EI 等对比指标。

输出 JSON: {
    "summary": { "intent": "意图描述", "scope": "数据范围", "metrics": "指标", "logic": "计算逻辑" },
    "code": "df_sub = df[...]\nresults = {'标题': df_sub}"
}
```

- `meta_data`：由 `build_metadata(df, time_context)` 生成，包含时间列、MAT、YTD 以及各列类型与示例值。

---

### ③ Analysis 模式：分析计划（角度拆解）

- **模型**：`gemini-2.0-flash`，普通文本（代码从回复中 parse 出 JSON）。
- **提示词**（`prompt_plan`，约 431–451 行）：

```text
你是一位医药行业 BI 专家。请将问题："{query_text}" 拆解为 2-5 个分析角度。
结合时间动态（MAT/YTD）和竞争视角进行分析。

【元数据】{meta_data}
【历史记录】{history_context}
【时间上下文】MAT: {mat_list}, YTD: {ytd_list}

【关键指令】
0. 数据源唯一入口：环境中只有名为 `df` 的 DataFrame。
1. 严禁使用未定义变量；如需筛选请先定义 df_sub 等。
2. 严禁臆造 Key；用 unique() 或模糊匹配确认名称。
3. 严禁绘图。
4. 每个角度的代码最终结果必须赋值给变量 `result`。
5. 语言：中文。
6. 市场表现尽量给份额、同比、EI 等对比指标。

输出 JSON: { "intent_analysis": "意图深度解析(Markdown)", "angles": [ {"title": "分析角度标题", "description": "描述", "code": "df_sub = df[...]\nresult = df_sub..."} ] }
```

---

### ④ Analysis 模式：每个角度的深度解读

- **模型**：`gemini-2.0-flash`。
- **提示词**（`mini_prompt`，约 496–500 行，每个角度执行一次）：

```text
对以下数据做深度解读（200字内）。
数据预览：\n{res_df.head(20).to_string()}
要求：提炼趋势/异常，结合业务含义，语言专业。
```

- `res_df` 为该角度 `exec(angle["code"])` 得到并 `normalize_result` 后的 DataFrame。

---

### ⑤ Analysis 模式：综合洞察

- **模型**：`gemini-2.0-flash`。
- **提示词**（`final_prompt`，约 519–523 行）：

```text
问题: "{query_text}"
各角度发现: {all_findings}
生成最终洞察 (Markdown)。严禁建议，仅陈述事实。
```

- `all_findings` 为各角度的 `[标题]: [深度解读]` 拼接成的一段文本。

---

## 5. 小结表

| 分支 | 是否调 API | 调用次数（单次提问） | 模型 | 提示词作用 |
|------|------------|----------------------|------|------------|
| 规则引擎 | 否 | 0 | - | - |
| Gemini + simple | 是 | 2 | 均为 gemini-2.0-flash | ① 意图路由 ② 取数代码+summary |
| Gemini + analysis | 是 | 3 + N + 1 | 均为 gemini-2.0-flash | ① 意图路由 ③ 分析计划 ④ 每角度解读×N ⑤ 综合洞察 |
| Gemini + irrelevant | 是 | 1 | gemini-2.0-flash | ① 意图路由 |

- N = 分析角度个数（通常 2–5）。
